#!/usr/bin/env bash
set -euo pipefail

# Podman dev container wrapper (refactored)
# UI: devc [options...] [command] [mode] <command-args...>
#   commands: start | stop | status | shell | run
#   modes:    install | work | review | quarantine
#   options:  --image|-i IMG  --projdir|-p DIR  --cwd|-d DIR  --one-off|-1  --help|-h

IMAGE_DEFAULT="devc/base:latest"
MEM_LIMIT="${DEVC_MEM_LIMIT:-16g}"
PIDS_LIMIT="${DEVC_PIDS_LIMIT:-2048}"
REVIEW_PRELUDE='set -e; rsync -a --delete /src/ /workdir/ 2>/tmp/rsync.log || echo "Warning: rsync failed" >&2;'

abs_path() { perl -MCwd=abs_path -e 'print abs_path(shift)' "$1"; }
hash_short() { printf "%s" "$1" | sha256sum | cut -c1-12; }

usage_short() {
  echo "Usage: devc [options...] [command] [mode] <command-args...>" >&2
  echo "Try 'devc --help' for more information." >&2
}

usage_help() {
  cat <<'EOF'
Usage:
  devc [options...] [command] [mode] <command-args...>

Commands:
  start      Ensure container for project/mode is running (sleep infinity)
  stop       Stop and remove container for project/mode
  status     Show container status; with [mode] show only that container
  shell      Start container and open interactive shell
  run        Run a shell command inside the container

Modes:
  install    Cache volumes read-write; workdir /home/dev; project mounted rw
  work       Cache volumes read-only; workdir /workspace; project mounted rw
  review     All mounts read-only; project at /src; rsync to scratch at /workdir
  quarantine Like review but with network disabled

Options:
  -i, --image IMG     Image to use (default auto-detected per project)
  -p, --projdir DIR   Project directory (absolute or relative to original PWD)
  -d, --cwd DIR       Change working directory before resolving project
  -1, --one-off       For shell/run: use one-off run container
  -h, --help          Show this help and exit

Notes:
  - For 'status', [mode] is optional; otherwise [mode] is required.
  - Final PWD must be the project directory or a subdirectory thereof.
EOF
}

# Parse options first (do not perform actions yet)
ORIG_PWD="$PWD"
OPT_IMAGE=""
OPT_PROJDIR=""
OPT_CWD=""
ONE_OFF=0

ARGS=()
while [[ $# -gt 0 ]]; do
  case "${1}" in
    -h|--help)
      usage_help
      exit 0
      ;;
    -i|--image)
      [[ $# -ge 2 ]] || { echo "Missing value for $1" >&2; exit 2; }
      OPT_IMAGE="$2"; shift 2; continue
      ;;
    -p|--projdir)
      [[ $# -ge 2 ]] || { echo "Missing value for $1" >&2; exit 2; }
      OPT_PROJDIR="$2"; shift 2; continue
      ;;
    -d|--cwd)
      [[ $# -ge 2 ]] || { echo "Missing value for $1" >&2; exit 2; }
      OPT_CWD="$2"; shift 2; continue
      ;;
    -1|--one-off)
      ONE_OFF=1; shift; continue
      ;;
    --)
      shift; break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage_short
      exit 2
      ;;
    *)
      ARGS+=("$1"); shift; continue
      ;;
  esac
done
if [[ $# -gt 0 ]]; then
  ARGS+=("$@")
fi

# Evaluate --cwd first
if [[ -n "$OPT_CWD" ]]; then
  cd "$OPT_CWD"
fi

# Resolve project directory
if [[ -n "$OPT_PROJDIR" ]]; then
  if [[ "$OPT_PROJDIR" = /* ]]; then
    PROJ_DIR="$OPT_PROJDIR"
  else
    PROJ_DIR="$ORIG_PWD/$OPT_PROJDIR"
  fi
else
  if git_root="$(git rev-parse --show-toplevel 2>/dev/null)"; then
    PROJ_DIR="$git_root"
  else
    PROJ_DIR="$PWD"
  fi
fi
PROJ_DIR="$(abs_path "$PROJ_DIR")"

# Ensure current directory is within project directory
CUR_PWD="$(pwd -P)"
case "$CUR_PWD" in
  "$PROJ_DIR"|"$PROJ_DIR"/*) ;;
  *)
    echo "Error: Current directory ($CUR_PWD) must be within project directory ($PROJ_DIR)." >&2
    exit 2
    ;;
esac

# Container base name from project
CNAME="devc-$(basename "$PROJ_DIR")-$(hash_short "$PROJ_DIR")"

# Detect image if not overridden
detect_image() {
  if [[ -f "$PROJ_DIR/pyproject.toml" || -f "$PROJ_DIR/requirements.txt" ]]; then
    echo "devc/base:latest"
  elif [[ -f "$PROJ_DIR/renv.lock" || -f "$PROJ_DIR/DESCRIPTION" ]]; then
    echo "devc/r-base:latest"
  elif [[ -f "$PROJ_DIR/package.json" ]]; then
    echo "devc/base:latest"
  elif [[ -f "$PROJ_DIR/Cargo.toml" ]]; then
    echo "devc/base:latest"
  else
    echo "$IMAGE_DEFAULT"
  fi
}
IMAGE="${OPT_IMAGE:-$(detect_image)}"

# Positional parsing: [command] [mode] <command-args...>
COMMAND="${ARGS[0]:-}"
if [[ -z "$COMMAND" ]]; then
  usage_short
  exit 2
fi

ALLOWED_COMMANDS=(start stop status shell run)
case " $COMMAND " in
  " start "|" stop "|" status "|" shell "|" run ") ;;
  *)
    echo "Unknown command: $COMMAND" >&2
    usage_short
    exit 2
    ;;
esac

MODE="${ARGS[1]:-}"
ALLOWED_MODES=(install work review quarantine)
is_valid_mode() {
  case " $1 " in
    " install "|" work "|" review "|" quarantine ") return 0 ;;
    *) return 1 ;;
  esac
}

if [[ "$COMMAND" != "status" ]]; then
  if [[ -z "$MODE" ]]; then
    echo "Missing mode. Expected one of: install|work|review|quarantine" >&2
    usage_short
    exit 2
  fi
  if ! is_valid_mode "$MODE"; then
    echo "Invalid mode: $MODE (expected install|work|review|quarantine)" >&2
    exit 2
  fi
fi

# Remaining args for 'run'
CMD_ARGS=()
if [[ "$COMMAND" == "status" ]]; then
  if [[ -n "$MODE" ]] && ! is_valid_mode "$MODE"; then
    echo "Invalid mode: $MODE (expected install|work|review|quarantine)" >&2
    exit 2
  fi
  CMD_ARGS=("${ARGS[@]:2}")
else
  CMD_ARGS=("${ARGS[@]:2}")
fi

# Helper: names and state
container_name_for_mode() { echo "${CNAME}-${1}"; }
container_exists() { podman container exists "$1"; }
container_running() {
  [[ "$(podman inspect -f '{{.State.Running}}' "$1" 2>/dev/null || echo false)" == "true" ]]
}
scratch_vol_name() { echo "devc_scratch_$(hash_short "$PROJ_DIR")"; }

ensure_scratch_volume() {
  local vol; vol="$(scratch_vol_name)"
  podman volume exists "$vol" || podman volume create "$vol" >/dev/null
}

ensure_cache_volumes() {
  local entry src
  for entry in "${CACHE_VOLUMES[@]}"; do
    src="${entry%%:*}"
    podman volume exists "$src" || podman volume create "$src" >/dev/null
  done
}

# Central cache volumes list: "volume:target"
CACHE_VOLUMES=(
  "devc_pip_cache:/home/dev/.cache/pip"
  "devc_npm_cache:/home/dev/.npm"
  "devc_renv_cache:/home/dev/.cache/R/renv"
  "devc_rpackages_cache:/home/dev/R"
)

add_cache_mounts() {
  local rwmode="$1"  # ro|rw
  local -n out="$2"
  local entry src target
  ensure_cache_volumes
  for entry in "${CACHE_VOLUMES[@]}"; do
    src="${entry%%:*}"; target="${entry#*:}"
    out+=( --mount=type=volume,src="$src",target="$target",${rwmode},z )
  done
}

# Build podman run args into provided array variable name
build_run_args() {
  local mode="$1"
  local -n out="$2"
  out=(
    --userns=keep-id:uid=1000,gid=1000
    --cap-drop=ALL --security-opt=no-new-privileges
    --pids-limit="$PIDS_LIMIT" --memory="$MEM_LIMIT"
    --ipc=private --uts=private --cgroupns=private
  )
  if [[ "$mode" == "quarantine" ]]; then
    out+=(--network none)
  fi
  case "$mode" in
    work)
      out+=( --mount=type=bind,src="$PROJ_DIR",target=/workspace,rw,z )
      add_cache_mounts ro out
      out+=( --workdir=/workspace )
      ;;
    install)
      out+=( --mount=type=bind,src="$PROJ_DIR",target=/workspace,rw,z )
      add_cache_mounts rw out
      out+=( --workdir=/home/dev )
      ;;
    review|quarantine)
      ensure_scratch_volume
      local scratch_vol; scratch_vol="$(scratch_vol_name)"
      out+=(
        --mount=type=bind,src="$PROJ_DIR",target=/src,ro,z
        --mount=type=volume,src="$scratch_vol",target=/workdir
      )
      add_cache_mounts ro out
      out+=( --workdir=/workdir )
      ;;
  esac
}

ensure_running_container() {
  local mode="$1"; local name; name="$(container_name_for_mode "$mode")"
  if container_running "$name"; then return 0; fi
  if container_exists "$name"; then
    # Start previously created container
    podman start "$name" >/dev/null
    return 0
  fi
  local -a args=()
  build_run_args "$mode" args
  case "$mode" in
    review|quarantine)
      podman run -d --name "$name" \
        "${args[@]}" \
        "$IMAGE" bash -lc "$REVIEW_PRELUDE exec sleep infinity"
      ;;
    *)
      podman run -d --name "$name" \
        "${args[@]}" \
        "$IMAGE" sleep infinity
      ;;
  esac
}

exec_shell_in_container() {
  local mode="$1"; local name; name="$(container_name_for_mode "$mode")"
  podman exec -it "$name" bash -l
}

# Add this helper near the other helpers
join_cmd() {
  local out="" first=1 arg esc
  for arg in "$@"; do
    printf -v esc '%q' "$arg"
    if [[ $first -eq 1 ]]; then
      out="$esc"; first=0
    else
      out+=" $esc"
    fi
  done
  printf '%s' "$out"
}

exec_run_in_container() {
  local mode="$1"; shift
  local name; name="$(container_name_for_mode "$mode")"
  local cmd; cmd="$(join_cmd "$@")"
  podman exec -it "$name" bash -lc "$cmd"
}

one_off_shell() {
  local mode="$1"; local name; name="$(container_name_for_mode "$mode")"
  local one_off_name="${name}-oneoff-$$"
  local -a args=()
  build_run_args "$mode" args
  case "$mode" in
    review|quarantine)
      podman run --rm -it --name "$one_off_name" \
        "${args[@]}" \
        "$IMAGE" bash -lc "$REVIEW_PRELUDE cd /workdir; exec bash -l"
      ;;
    *)
      podman run --rm -it --name "$one_off_name" \
        "${args[@]}" \
        "$IMAGE" bash -l
      ;;
  esac
}

one_off_run() {
  local mode="$1"; shift
  local name; name="$(container_name_for_mode "$mode")-oneoff-$$"
  local -a args=()
  build_run_args "$mode" args
  local cmd; cmd="$(join_cmd "$@")"
  case "$mode" in
    review|quarantine)
      podman run --rm -it --name "$name" \
        "${args[@]}" \
        "$IMAGE" bash -lc "$REVIEW_PRELUDE cd /workdir; $cmd"
      ;;
    *)
      podman run --rm -it --name "$name" \
        "${args[@]}" \
        "$IMAGE" bash -lc "$cmd"
      ;;
  esac
}

status_one() {
  local mode="$1"; local name; name="$(container_name_for_mode "$mode")"
  if container_exists "$name"; then
    podman ps -a --filter "name=$name" --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
  else
    printf "%s\t%s\t%s\n" "$name" "<absent>" "$IMAGE"
  fi
}

# Validate contradictory options
if [[ "$ONE_OFF" -eq 1 && ( "$COMMAND" == "start" || "$COMMAND" == "stop" || "$COMMAND" == "status" ) ]]; then
  echo "--one-off is only valid with 'shell' or 'run'." >&2
  exit 2
fi

# Reject unexpected extra positional arguments per command
case "$COMMAND" in
  status)
    if (( ${#ARGS[@]} > 2 )); then
      extras=("${ARGS[@]:2}")
      echo "Unexpected arguments for 'status': ${extras[*]}" >&2
      usage_short
      exit 2
    fi
    ;;
  start|stop|shell)
    if (( ${#ARGS[@]} > 2 )); then
      extras=("${ARGS[@]:2}")
      echo "Unexpected arguments for '$COMMAND': ${extras[*]}" >&2
      usage_short
      exit 2
    fi
    ;;
  run)
    if (( ${#ARGS[@]} < 3 )); then
      echo "Missing command to run." >&2
      usage_short
      exit 2
    fi
    ;;
esac

case "$COMMAND" in
  status)
    if [[ -z "${MODE:-}" ]]; then
      for m in install work review quarantine; do
        status_one "$m"
      done
    else
      status_one "$MODE"
    fi
    ;;
  start)
    ensure_running_container "$MODE"
    ;;
  stop)
    name="$(container_name_for_mode "$MODE")"
    if container_exists "$name"; then
      podman stop "$name" >/dev/null || true
      podman rm "$name" >/dev/null || true
    fi
    ;;
  shell)
    name="$(container_name_for_mode "$MODE")"
    if [[ "$ONE_OFF" -eq 1 ]]; then
      one_off_shell "$MODE"
    else
      ensure_running_container "$MODE"
      exec_shell_in_container "$MODE"
    fi
    ;;
  run)
    name="$(container_name_for_mode "$MODE")"
    if [[ "$ONE_OFF" -eq 1 ]]; then
      one_off_run "$MODE" "${CMD_ARGS[@]}"
    else
      ensure_running_container "$MODE"
      exec_run_in_container "$MODE" "${CMD_ARGS[@]}"
    fi
    ;;
esac

