#!/usr/bin/env bash
set -euo pipefail

# Podman dev container wrapper (refactored)
# UI: devc [options...] [command] [mode] <command-args...>
#   commands: start | stop | pause | restart | sync | status | shell | cursor | run
#   modes:    install | work | review | quarantine
#   options:  --image|-i IMG  --projdir|-p DIR  --cwd|-d DIR  --one-off|-1  --help|-h

IMAGE_DEFAULT="devc/base:latest"
MEM_LIMIT="${DEVC_MEM_LIMIT:-16g}"
PIDS_LIMIT="${DEVC_PIDS_LIMIT:-2048}"
REVIEW_PRELUDE='rsync -a --delete /src/ /workspace/ 2>/tmp/rsync.log || echo "Warning: rsync failed" >&2;'
REVIEW_PRELUDE_EXIT_ON_ERROR='rsync -a --delete /src/ /workspace/ 2>/tmp/rsync.log || (echo "rsync failed for workspace" >&2; exit 1)'
CONFIG_PRELUDE_RSYNC='for entry in "$@"; do
  src="${entry#*:}"
  dst="${src%-cache}"
  rsync -a --delete "$src" "$dst" ||  (echo "rsync failed for $src" >&2; exit 1)
done;'
CONFIG_PRELUDE_LINK='for entry in "$@"; do
  src="${entry#*:}"
  dst="${src%-cache}"
  rm -rf -- "$dst" || (echo "rm failed for $dst" >&2; exit 1)
  ln -s -- "$src" "$dst" || (echo "ln -s failed for $src" >&2; exit 1)
done;'

abs_path() { perl -MCwd=abs_path -e 'print abs_path(shift)' "$1"; }
hash_short() { printf "%s" "$1" | sha256sum | cut -c1-12; }
to_hex() { local s="$1"; if command -v xxd >/dev/null 2>&1; then printf '%s' "$s" | xxd -p -c 0; elif command -v hexdump >/dev/null 2>&1; then printf '%s' "$s" | hexdump -v -e '/1 "%02x"'; else printf '%s' "$s" | od -An -tx1 | tr -d ' \n'; fi }

usage_short() {
  echo "Usage: devc [options...] [command] [mode] <command-args...>" >&2
  echo "Try 'devc --help' for more information." >&2
}

usage_help() {
  cat <<'EOF'
Usage:
  devc [options...] [command] [mode] <command-args...>

Commands:
  start      Ensure container for project/mode is running (sleep infinity)
  stop       Stop and remove container for project/mode
  pause      Stop container without removing it (resume with 'start')
  restart    Stop, remove, and start container fresh
  sync       Re-run rsync to refresh /workspace (review/quarantine only)
  status     Show container status; with [mode] show only that container
  shell      Start container and open interactive shell
  cursor     Ensure container is running and open Cursor attached to it
  run        Run a shell command inside the container

Modes:
  install    Cache volumes read-write; workdir /home/dev; project mounted rw
  work       Cache volumes read-only; workdir /workspace; project mounted rw
  review     All mounts read-only; project at /src; rsync to scratch at /workspace
  quarantine Like review but with network disabled

Options:
  -i, --image IMG     Image to use (default auto-detected per project)
  -p, --projdir DIR   Project directory (absolute or relative to original PWD)
  -d, --cwd DIR       Change working directory before resolving project
  -1, --one-off       For shell/run: use one-off run container
  -h, --help          Show this help and exit

Notes:
  - For 'status', [mode] is optional; otherwise [mode] is required.
  - Final PWD must be the project directory or a subdirectory thereof.
  - 'sync' works only for review|quarantine and reruns rsync to refresh /workspace.
  - 'cursor' requires the 'cursor' CLI on the host and opens /workspace.
EOF
}

# Parse options first (do not perform actions yet)
ORIG_PWD="$PWD"
OPT_IMAGE=""
OPT_PROJDIR=""
OPT_CWD=""
ONE_OFF=0

ARGS=()
while [[ $# -gt 0 ]]; do
  case "${1}" in
    -h|--help)
      usage_help
      exit 0
      ;;
    -i|--image)
      [[ $# -ge 2 ]] || { echo "Missing value for $1" >&2; exit 2; }
      OPT_IMAGE="$2"; shift 2; continue
      ;;
    -p|--projdir)
      [[ $# -ge 2 ]] || { echo "Missing value for $1" >&2; exit 2; }
      OPT_PROJDIR="$2"; shift 2; continue
      ;;
    -d|--cwd)
      [[ $# -ge 2 ]] || { echo "Missing value for $1" >&2; exit 2; }
      OPT_CWD="$2"; shift 2; continue
      ;;
    -1|--one-off)
      ONE_OFF=1; shift; continue
      ;;
    --)
      shift; break
      ;;
    -*)
      echo "Unknown option: $1" >&2
      usage_short
      exit 2
      ;;
    *)
      ARGS+=("$1"); shift; continue
      ;;
  esac
done
if [[ $# -gt 0 ]]; then
  ARGS+=("$@")
fi

# Evaluate --cwd first
if [[ -n "$OPT_CWD" ]]; then
  cd "$OPT_CWD"
fi

# Resolve project directory
if [[ -n "$OPT_PROJDIR" ]]; then
  if [[ "$OPT_PROJDIR" = /* ]]; then
    PROJ_DIR="$OPT_PROJDIR"
  else
    PROJ_DIR="$ORIG_PWD/$OPT_PROJDIR"
  fi
else
  if git_root="$(git rev-parse --show-toplevel 2>/dev/null)"; then
    PROJ_DIR="$git_root"
  else
    PROJ_DIR="$PWD"
  fi
fi
PROJ_DIR="$(abs_path "$PROJ_DIR")"

if [[ ! -d "$PROJ_DIR" ]]; then
    echo "Error: Project directory does not exist: $PROJ_DIR" >&2
    exit 2
fi

# Ensure current directory is within project directory
CUR_PWD="$(pwd -P)"
case "$CUR_PWD" in
  "$PROJ_DIR"|"$PROJ_DIR"/*) ;;
  *)
    echo "Error: Current directory ($CUR_PWD) must be within project directory ($PROJ_DIR)." >&2
    exit 2
    ;;
esac

# Relative subpath from project to current dir (may be empty)
if [[ "$CUR_PWD" == "$PROJ_DIR" ]]; then
  REL_SUBPATH=""
else
  REL_SUBPATH="${CUR_PWD#"$PROJ_DIR"/}"
fi

# Container base name from project
CNAME="devc-$(basename "$PROJ_DIR")-$(hash_short "$PROJ_DIR")"

# Detect image if not overridden
detect_image() {
  if [[ -f "$PROJ_DIR/pyproject.toml" || -f "$PROJ_DIR/requirements.txt" ]]; then
    echo "devc/base:latest"
  elif [[ -f "$PROJ_DIR/renv.lock" || -f "$PROJ_DIR/DESCRIPTION" ]]; then
    echo "devc/r-base:latest"
  elif [[ -f "$PROJ_DIR/package.json" ]]; then
    echo "devc/base:latest"
  elif [[ -f "$PROJ_DIR/Cargo.toml" ]]; then
    echo "devc/base:latest"
  else
    echo "$IMAGE_DEFAULT"
  fi
}
IMAGE="${OPT_IMAGE:-$(detect_image)}"

# Positional parsing: [command] [mode] <command-args...>
COMMAND="${ARGS[0]:-}"
if [[ -z "$COMMAND" ]]; then
  usage_short
  exit 2
fi

ALLOWED_COMMANDS=(start stop pause restart sync status shell cursor run)
case " $COMMAND " in
  " start "|" stop "|" pause "|" restart "|" sync "|" status "|" shell "|" cursor "|" run ") ;;
  *)
    echo "Unknown command: $COMMAND" >&2
    usage_short
    exit 2
    ;;
esac

MODE="${ARGS[1]:-}"
ALLOWED_MODES=(install work review quarantine)
is_valid_mode() {
  case " $1 " in
    " install "|" work "|" review "|" quarantine ") return 0 ;;
    *) return 1 ;;
  esac
}

if [[ "$COMMAND" != "status" ]]; then
  if [[ -z "$MODE" ]]; then
    echo "Missing mode. Expected one of: install|work|review|quarantine" >&2
    usage_short
    exit 2
  fi
  if ! is_valid_mode "$MODE"; then
    echo "Invalid mode: $MODE (expected install|work|review|quarantine)" >&2
    exit 2
  fi
fi

# Remaining args for 'run'
CMD_ARGS=()
if [[ "$COMMAND" == "status" ]]; then
  if [[ -n "$MODE" ]] && ! is_valid_mode "$MODE"; then
    echo "Invalid mode: $MODE (expected install|work|review|quarantine)" >&2
    exit 2
  fi
  CMD_ARGS=("${ARGS[@]:2}")
else
  CMD_ARGS=("${ARGS[@]:2}")
fi

# Helper: names and state
container_name_for_mode() { echo "${CNAME}-${1}"; }
container_exists() { podman container exists "$1"; }
container_running() {
  [[ "$(podman inspect -f '{{.State.Running}}' "$1" 2>/dev/null || echo false)" == "true" ]]
}
scratch_vol_name() { echo "devc_scratch_$(hash_short "$PROJ_DIR")"; }

# Prevent launching additional 'install' containers if any are already running
ensure_no_install_running() {
  local exclude_name="${1:-}"
  local running
  running="$(podman ps --format '{{.Names}}' | grep -E '^devc-.*-install($|-)' || true)"
  if [[ -n "$exclude_name" ]]; then
    running="$(printf '%s\n' "$running" | grep -v -x "$exclude_name" || true)"
  fi
  if [[ -n "$running" ]]; then
    echo "Error: Refusing to launch 'install' mode container while another 'install' container is running:" >&2
    echo "  $(printf '%s' "$running" | tr '\n' ' ')" >&2
    echo "Only one install-mode container may run at a time due to shared cache volumes." >&2
    exit 1
  fi
}

ensure_scratch_volume() {
  local vol; vol="$(scratch_vol_name)"
  podman volume exists "$vol" || podman volume create "$vol" >/dev/null
}

ensure_cache_volumes() {
  local entry src
  for entry in "${CACHE_VOLUMES[@]}" "${CONFIG_VOLUMES[@]}"; do
    src="${entry%%:*}"
    podman volume exists "$src" || podman volume create "$src" >/dev/null
  done
}

# Central cache volumes list: "volume:target"
CACHE_VOLUMES=(
  "devc_pip_cache:/home/dev/.cache/pip"
  "devc_npm_cache:/home/dev/.npm"
  "devc_renv_cache:/home/dev/.cache/R/renv"
  "devc_rpackages_cache:/home/dev/R"
)
CONFIG_VOLUMES=(
  "devc_cursor_dir:/home/dev/.cursor-server-cache"
  "devc_claude_dir:/home/dev/.claude-cache"
  "devc_config_dir:/home/dev/.config-cache"
)

add_cache_mounts() {
  local rwmode="$1"  # ro|rw
  local out_var="$2"
  local -n __arr_ref="$out_var"
  local entry src target
  ensure_cache_volumes
  for entry in "${CACHE_VOLUMES[@]}" "${CONFIG_VOLUMES[@]}"; do
    src="${entry%%:*}"; target="${entry#*:}"
    __arr_ref+=( --mount=type=volume,src="$src",target="$target",${rwmode},relabel=shared )
  done
}

# Compute container cwd based on mode and relative subpath
container_target_dir() {
  local mode="$1"; local out_var="$2"; local -n __out_ref="$out_var"
  case "$mode" in
    install)
      __out_ref="/home/dev"  # unchanged in 'install' mode for safety
      ;;
    *)
      if [[ -n "$REL_SUBPATH" ]]; then __out_ref="/workspace/$REL_SUBPATH"; else __out_ref="/workspace"; fi
      ;;
  esac
}

# Build podman run args into provided array variable name
build_run_args() {
  # note that --workdir can not be part here, since it is sometimes passed as argument, sometimes used as part of the
  # bash command after rsyncing.
  local mode="$1"
  local out_var="$2"
  local -n __arr_ref="$out_var"
  __arr_ref=(
    --userns=keep-id:uid=1000,gid=1000
    --cap-drop=ALL --security-opt=no-new-privileges
    --pids-limit="$PIDS_LIMIT" --memory="$MEM_LIMIT"
    --ipc=private --uts=private --cgroupns=private
  )
  if [[ "$mode" == "quarantine" ]]; then
    __arr_ref+=(--network none)
  fi
  case "$mode" in
    work)
      __arr_ref+=( --mount=type=bind,src="$PROJ_DIR",target=/workspace,rw,z )
      add_cache_mounts ro "$out_var"
      ;;
    install)
      __arr_ref+=( --mount=type=bind,src="$PROJ_DIR",target=/workspace,rw,z )
      add_cache_mounts rw "$out_var"
      ;;
    review|quarantine)
      ensure_scratch_volume
      local scratch_vol; scratch_vol="$(scratch_vol_name)"
      __arr_ref+=(
        --mount=type=bind,src="$PROJ_DIR",target=/src,ro,z
        --mount=type=volume,src="$scratch_vol",target=/workspace
      )
      add_cache_mounts ro "$out_var"
      ;;
  esac
}

ensure_running_container() {
  local mode="$1"; local name; name="$(container_name_for_mode "$mode")"
  if container_running "$name"; then return 0; fi
  # Prevent multiple concurrent 'install' containers across projects
  if [[ "$mode" == "install" ]]; then
    ensure_no_install_running "$name"
  fi
  if container_exists "$name"; then
    podman start "$name" >/dev/null
    return 0
  fi
  local -a args=()
  build_run_args "$mode" args
  # Always create containers with a simple long-running command
  podman run -d --init --name "$name" \
    "${args[@]}" \
    "$IMAGE" sleep infinity
  if [[ "$mode" == "install" ]]; then
    podman exec "$name" bash -lc "$CONFIG_PRELUDE_LINK" _ "${CONFIG_VOLUMES[@]}"
  else
    podman exec "$name" bash -lc "$CONFIG_PRELUDE_RSYNC" _ "${CONFIG_VOLUMES[@]}"
  fi
  # For review/quarantine, perform initial one-time rsync into scratch volume
  case "$mode" in
    review|quarantine)
      podman exec "$name" bash -lc "$REVIEW_PRELUDE"
      ;;
  esac
}

exec_shell_in_container() {
  local mode="$1"; local name; name="$(container_name_for_mode "$mode")"
  local target
  container_target_dir "$mode" target
  podman exec -it --workdir "$target" "$name" bash -l
}

join_cmd() {
  local out="" first=1 arg esc
  for arg in "$@"; do
    printf -v esc '%q' "$arg"
    if [[ $first -eq 1 ]]; then
      out="$esc"; first=0
    else
      out+=" $esc"
    fi
  done
  printf '%s' "$out"
}

exec_run_in_container() {
  local mode="$1"; shift
  local name; name="$(container_name_for_mode "$mode")"
  local cmd; cmd="$(join_cmd "$@")"
  local target; container_target_dir "$mode" target
  podman exec -it --workdir "$target" "$name" bash -lc "$cmd"
}

one_off_shell() {
  local mode="$1"; local name; name="$(container_name_for_mode "$mode")"
  local one_off_name="${name}-oneoff-$$"
  # Prevent one-off launch if any install container is already running
  if [[ "$mode" == "install" ]]; then
    ensure_no_install_running
  fi
  local -a args=()
  build_run_args "$mode" args
  local target; container_target_dir "$mode" target
  case "$mode" in
    review|quarantine)
      # cannot --workdir to target dir because it may not exist before REVIEW_PRELUDE.
      podman run --rm -it --name "$one_off_name" \
        "${args[@]}" \
        "$IMAGE" bash -lc "$REVIEW_PRELUDE $CONFIG_PRELUDE_RSYNC cd $(printf %q "$target"); exec bash -l" _ "${CONFIG_VOLUMES[@]}"
      ;;
    install)
      # link configs
      # also
      podman run --rm -it --workdir "$target" --name "$one_off_name" \
        "${args[@]}" \
        "$IMAGE" bash -lc "$CONFIG_PRELUDE_LINK exec bash -l" _ "${CONFIG_VOLUMES[@]}"
      ;;
    *)
      podman run --rm -it --workdir "$target" --name "$one_off_name" \
        "${args[@]}" \
        "$IMAGE" bash -lc "$CONFIG_PRELUDE_RSYNC exec bash -l" _ "${CONFIG_VOLUMES[@]}"
      ;;
  esac
}

one_off_run() {
  local mode="$1"; shift
  local name; name="$(container_name_for_mode "$mode")-oneoff-$$"
  # Prevent one-off launch if any install container is already running
  if [[ "$mode" == "install" ]]; then
    ensure_no_install_running
  fi
  local -a args=()
  build_run_args "$mode" args
  local cmd; cmd="$(join_cmd "$@")"
  local target; container_target_dir "$mode" target
  case "$mode" in
    review|quarantine)
      # cannot --workdir to target dir because it may not exist before REVIEW_PRELUDE.
      # we always link, one-off commands don't get to modify config files in non-install-modes
      podman run --rm -it --name "$name" \
        "${args[@]}" \
        "$IMAGE" bash -lc "$REVIEW_PRELUDE_EXIT_ON_ERROR $CONFIG_PRELUDE_LINK cd $(printf %q "$target"); $cmd"
      ;;
    *)
      podman run --rm -it --workdir "$target" --name "$name" \
        "${args[@]}" \
        "$IMAGE" bash -lc "$CONFIG_PRELUDE_LINK $cmd"
      ;;
  esac
}

status_one() {
  local mode="$1"; local name; name="$(container_name_for_mode "$mode")"
  if container_exists "$name"; then
    podman ps -a --filter "name=$name" --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
  else
    printf "%s\t%s\t%s\n" "$name" "<absent>" "$IMAGE"
  fi
}

# Validate contradictory options
if [[ "$ONE_OFF" -eq 1 && ( "$COMMAND" == "start" || "$COMMAND" == "stop" || "$COMMAND" == "pause" || "$COMMAND" == "restart" || "$COMMAND" == "sync" || "$COMMAND" == "status" || "$COMMAND" == "cursor" ) ]]; then
  echo "--one-off is only valid with 'shell' or 'run'." >&2
  exit 2
fi

# Reject unexpected extra positional arguments per command
case "$COMMAND" in
  status)
    if (( ${#ARGS[@]} > 2 )); then
      extras=("${ARGS[@]:2}")
      echo "Unexpected arguments for 'status': ${extras[*]}" >&2
      usage_short
      exit 2
    fi
    ;;
  start|stop|pause|restart|sync|shell|cursor)
    if (( ${#ARGS[@]} > 2 )); then
      extras=("${ARGS[@]:2}")
      echo "Unexpected arguments for '$COMMAND': ${extras[*]}" >&2
      usage_short
      exit 2
    fi
    ;;
  run)
    if (( ${#ARGS[@]} < 3 )); then
      echo "Missing command to run." >&2
      usage_short
      exit 2
    fi
    ;;
esac

case "$COMMAND" in
  status)
    if [[ -z "${MODE:-}" ]]; then
      for m in install work review quarantine; do
        status_one "$m"
      done
    else
      status_one "$MODE"
    fi
    ;;
  start)
    ensure_running_container "$MODE"
    ;;
  stop)
    name="$(container_name_for_mode "$MODE")"
    if container_exists "$name"; then
      podman stop "$name" >/dev/null || true
      podman rm "$name" >/dev/null || true
    fi
    ;;
  pause)
    name="$(container_name_for_mode "$MODE")"
    if container_exists "$name"; then
      podman stop "$name" >/dev/null || true
    fi
    ;;
  restart)
    name="$(container_name_for_mode "$MODE")"
    if container_exists "$name"; then
      podman stop "$name" >/dev/null || true
      podman rm "$name" >/dev/null || true
    fi
    ensure_running_container "$MODE"
    ;;
  sync)
    case "$MODE" in
      review|quarantine) ;;
      *)
        echo "'sync' is only supported for 'review' and 'quarantine' modes." >&2
        exit 2
        ;;
    esac
    ensure_running_container "$MODE"
    name="$(container_name_for_mode "$MODE")"
    # Re-run rsync and exit non-zero on failure
    podman exec "$name" bash -lc "$REVIEW_PRELUDE_EXIT_ON_ERROR"
    ;;
  shell)
    name="$(container_name_for_mode "$MODE")"
    if [[ "$ONE_OFF" -eq 1 ]]; then
      one_off_shell "$MODE"
    else
      ensure_running_container "$MODE"
      exec_shell_in_container "$MODE"
    fi
    ;;
  cursor)
    # Ensure container is running, then open Cursor attached-container to /workspace
    ensure_running_container "$MODE"
    name="$(container_name_for_mode "$MODE")"
    hex_name="$(to_hex "$name")"
    if ! command -v cursor >/dev/null 2>&1; then
      echo "Error: 'cursor' CLI not found on host PATH." >&2
      echo "Install Cursor CLI and try again." >&2
      exit 1
    fi
    if [[ "$MODE" == "install" ]]; then
      cursor --new-window --file-uri "vscode-remote://attached-container+${hex_name}/"
    else
      cursor --folder-uri "vscode-remote://attached-container+${hex_name}/workspace"
    fi
    ;;
  run)
    name="$(container_name_for_mode "$MODE")"
    if [[ "$ONE_OFF" -eq 1 ]]; then
      one_off_run "$MODE" "${CMD_ARGS[@]}"
    else
      ensure_running_container "$MODE"
      exec_run_in_container "$MODE" "${CMD_ARGS[@]}"
    fi
    ;;
esac

